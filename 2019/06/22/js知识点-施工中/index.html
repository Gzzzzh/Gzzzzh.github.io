<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="面试题,javascript,">




  


  <link rel="alternate" href="/atom.xml" title="Gzzzh" type="application/atom+xml">






<meta name="description" content="前言这篇文章会记录我的一些js知识点笔记，方便自己进行复习，长期施工…">
<meta name="keywords" content="面试题,javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="js知识点(施工中)">
<meta property="og:url" content="https://gzzzzh.github.io/2019/06/22/js知识点-施工中/index.html">
<meta property="og:site_name" content="Gzzzh">
<meta property="og:description" content="前言这篇文章会记录我的一些js知识点笔记，方便自己进行复习，长期施工…">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://seo-1255598498.file.myqcloud.com/full/5c33584700ba452eabd9dbede94cc076855855ec.jpg">
<meta property="og:image" content="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/19/167c4a2627fe55f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2019-09-06T07:01:46.388Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js知识点(施工中)">
<meta name="twitter:description" content="前言这篇文章会记录我的一些js知识点笔记，方便自己进行复习，长期施工…">
<meta name="twitter:image" content="http://seo-1255598498.file.myqcloud.com/full/5c33584700ba452eabd9dbede94cc076855855ec.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://gzzzzh.github.io/2019/06/22/js知识点-施工中/">





  <title>js知识点(施工中) | Gzzzh</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gzzzh</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://gzzzzh.github.io/2019/06/22/js知识点-施工中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gzzzh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gzzzh">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js知识点(施工中)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-22T23:56:42+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章会记录我的一些js知识点笔记，方便自己进行复习，长期施工…<br><a id="more"></a></p>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p><img src="http://seo-1255598498.file.myqcloud.com/full/5c33584700ba452eabd9dbede94cc076855855ec.jpg" alt></p>
<ol>
<li>只有构造函数才有prototype</li>
<li>构造函数的prototype或者实例的<strong>proto</strong>是一个空对象，这个空对象是一个对象实例，<strong>proto</strong>指向Object.prototype</li>
<li>Object.prototype的<strong>proto</strong>指向null，是原型链的尽头了</li>
<li>构造函数Function()的prototype和<strong>proto</strong>都指向了Function.prototype</li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一个函数里面生成并返回一个函数，返回的这个函数能读取到外部函数的变量，本质上闭包是内部函数和外部函数连接的桥梁</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>);  a.fun(<span class="number">1</span>);  a.fun(<span class="number">2</span>);  a.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);  c.fun(<span class="number">2</span>);  c.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="comment">//问:三行a,b,c的输出分别是什么？</span></span><br></pre></td></tr></table></figure>
<p>可以得出 </p>
<p>0,0,0 </p>
<p>0,1,2 </p>
<p>0,1,1</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以得知，第一个fun(0)是在调用第一层fun函数。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：</p>
<p>第后面几个fun(1),fun(2),fun(3),函数都是在调用第二层fun函数。</p>
<p>在第一次调用fun(0)时，o为undefined；</p>
<p>第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0</p>
<p>第四次同理；</p>
<p>即：最终答案为undefined,0,0,0</p>
<p><hr><br>先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是第二次执行的返回对象。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；</p>
<p>第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；</p>
<p>即最终答案：undefined,0,1,2</p>
<hr>

<p>根据前面两个例子，可以得知：</p>
<p>fun(0)为执行第一层fun函数，.fun(1)执行的是fun(0)返回的第二层fun函数，这里语句结束，遂c存放的是fun(1)的返回值，而不是fun(0)的返回值，所以c中闭包的也是fun(1)第二次执行的n的值。c.fun(2)执行的是fun(1)返回的第二层fun函数，c.fun(3)执行的也是fun(1)返回的第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；</p>
<p>第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1</p>
<p>即最终答案：undefined,0,1,1</p>
<hr>

<p>闭包有两个用处，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在函数调用后被自动清除。</p>
<p>闭包缺点，闭包会使函数的变量存放在内存中，会增加内存的消耗，发生内存泄露，时间长了会导致内存溢出。增加了代码的复杂度，不便于维护。</p>
<p>在实际中闭包应该不能滥用，能不用到闭包的就不用</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承分为7种，效果比较好的常用的有3种，分别是组合继承，寄生组合继承，class继承</p>
<h3 id="组合继承-最常用"><a href="#组合继承-最常用" class="headerlink" title="组合继承(最常用)"></a>组合继承(最常用)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>,name,age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">'带娃'</span>,<span class="number">22</span>)</span><br><span class="line">child.getName()</span><br><span class="line">child.getAge()</span><br><span class="line">child.color.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.color);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="string">'五娃'</span>,<span class="number">30</span>)</span><br><span class="line">child1.getName()</span><br><span class="line">child1.getAge()</span><br><span class="line"><span class="built_in">console</span>.log(child1.color);</span><br></pre></td></tr></table></figure>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>不存在父类引用属性共享问题</li>
<li>可以给父类构造参数传参</li>
<li>通过原型属性设置方法，使得函数可以复用</li>
<li>最常用的继承方式</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>子类调用了两次父类构造函数，生成了两个父类实例，第二次调用时改变了指向第一个实例的指针，使得第一个实例多余了</p>
<h3 id="寄生组合继承-最佳"><a href="#寄生组合继承-最佳" class="headerlink" title="寄生组合继承(最佳)"></a>寄生组合继承(最佳)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>,name,age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPrototype</span>(<span class="params">Child,Parent</span>) </span>&#123; <span class="comment">//获得父类原型上的方法，也就是把原型链连接起来</span></span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="built_in">Object</span>.create(Parent.prototype) <span class="comment">//创建一个父类原型的副本，相当于prototype.__proto__ = Parent.prototype</span></span><br><span class="line">  Child.prototype = prototype</span><br><span class="line">   Child.prototype.constructor = Child </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initPrototype(Child,Parent)</span><br><span class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//顺序不能调转，不然原型会被重写</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">'带娃'</span>,<span class="number">22</span>)</span><br><span class="line">child.getName()</span><br><span class="line">child.getAge()</span><br><span class="line">child.color.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.color);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="string">'五娃'</span>,<span class="number">30</span>)</span><br><span class="line">child1.getName()</span><br><span class="line">child1.getAge()</span><br><span class="line"><span class="built_in">console</span>.log(child1.color);</span><br></pre></td></tr></table></figure>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>和上面一样</li>
<li>只调用了一次父类构造函数，避免了多余的数据</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>用起来麻烦</p>
<h3 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  getName()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name,age,sex)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name,age)</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">  &#125;</span><br><span class="line">  getAge()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age,<span class="keyword">this</span>.sex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">'带娃'</span>, <span class="number">22</span> ,<span class="string">'male'</span>)</span><br><span class="line">child.getName()</span><br><span class="line">child.getAge()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="string">'五娃'</span>,<span class="number">30</span> , <span class="string">'male'</span>)</span><br><span class="line">child1.getName()</span><br><span class="line">child1.getAge()</span><br></pre></td></tr></table></figure>
<h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>使用简单方便</li>
<li>上面的优点都有</li>
</ol>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>ES6语法，有一定的兼容性问题，经测试IE浏览器不支持</p>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在javascript中，我们将数据分成基本数据类型(原始值)与引用类型</p>
<ol>
<li>基本数据类型的值是按值访问的，基本类型的值是不可变的</li>
<li>引用类型的值是按引用访问的，引用类型的是动态可变的，意思是我们访问的是值的地址，这个地址指向这些值</li>
<li>基本数据类型的比较是值的</li>
<li>引用类型的比较是引用地址的比较</li>
</ol>
<p>根据这些特点，我们所涉及的拷贝对象，也都是针对引用类型的，这就引出了浅拷贝和深拷贝</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是指只复制一层对象，当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>
<p>举个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice()</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[ 1, [ 6, 3 ], 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[ 1, [ 6, 3 ], 4, 5 ]</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>–</th>
<th>和原数据是否指向同一对象</th>
<th>第一层数据为基本数据类型</th>
<th>原数据中包含子对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>赋值</td>
<td>是</td>
<td>改变会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>浅拷贝</td>
<td>否</td>
<td>改变不会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
</tbody>
</table>
<p>其他浅拷贝的方法：</p>
<ol>
<li>Array.prototype.slice()</li>
<li>Array.prototype.concat()</li>
<li>Object.assign</li>
<li>拓展操作符…</li>
</ol>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>浅拷贝由于只是复制一层对象的属性，当遇到有子对象的情况时，子对象就会互相影响。所以，深拷贝是对对象以及对象的所有子对象进行拷贝</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们实现的思路就是当遇到子对象的时候，再次进行浅拷贝，如此递归。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> targetObj = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        targetObj[key] = deepCopy(obj[key])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetObj[key] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> targetObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  key: &#123;</span><br><span class="line">      id: <span class="number">22</span></span><br><span class="line">  &#125;,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = deepCopy(obj1);</span><br><span class="line"></span><br><span class="line">obj1.arr.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.arr); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.key === obj2.key); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.func === obj2.func); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>对于深拷贝的对象，改变源对象不会对得到的对象有影响。只是在拷贝的过程中源对象的方法丢失了，这是因为在序列化 JavaScript 对象时，所有函数和原型成员会被有意忽略</p>
<p>还有一种实现深拷贝的方式是利用 JSON 对象中的 parse 和 stringify，JOSN 对象中的 stringify 可以把一个 js 对象序列化为一个 JSON 字符串，parse 可以把 JSON 字符串反序列化为一个 js 对象，通过这两个方法，也可以实现对象的深拷贝。</p>
<p>不过这种方法有很多缺点</p>
<ol>
<li>时间对象转换过来是字符串</li>
<li>正则，Error对象转换过来会变成空对象</li>
<li>undefined，函数回丢失</li>
<li>NaN，Infinity和-Infinity会变成null</li>
<li>只能序列化自身的枚举属性</li>
</ol>
<h2 id="判断JS数据类型"><a href="#判断JS数据类型" class="headerlink" title="判断JS数据类型"></a>判断JS数据类型</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof操作符：返回一个字符串，对于简单数据类型来说，返回其基本数据类型，函数对象返回function，其他对象(包括null)均返回object</p>
<h4 id="为什么null返回的是object"><a href="#为什么null返回的是object" class="headerlink" title="为什么null返回的是object"></a>为什么null返回的是object</h4><p>在JS最初版本使用的32位系统，为了性能使用低位存储变量类型信息，000开头的是对象，而null是全为0</p>
<p>null也返回object的原因：在第一版js中，只有5种数据类型，都设计成32位，其中最低的3位用来表述数据类型，对象为000，而null设计成作为object的一种特殊情况，32位全是0</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof：用来判断A是否是B的实例，表达式为A instanceof B，返回一个布尔值，他只能判断两个对象是否有实例关系，不能判断一个对象的具体实例，根据原型链往上寻找</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor: 当一个函数被定义时，JS引擎会为其添加prototype原型，然后再在 prototype上添加一个 constructor 属性，并让其指向该函数的引用，但这种方法很不稳定，因为prototype可以重新，重写之后默认为Object，因此我们在重写原型的时候一般也要重新设置constructor</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>toString: Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">11</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>
<h2 id="undefined和null的区别"><a href="#undefined和null的区别" class="headerlink" title="undefined和null的区别"></a>undefined和null的区别</h2><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>null表示没有对象，即该处不应该有值</p>
<ol>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为对象原型链的终点</li>
<li><p>判断的时候不能用==，要用===</p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>undefined表示缺少值，就是此处应该有一个值，但是还没有定义</p>
</li>
<li><p>变量被声明，但没有赋值就等于undefined</p>
</li>
<li>调用函数时，应该提供的参数没有提供，该参数为undefined</li>
<li>对象没有赋值的属性，该属性值为undefined</li>
<li>函数没有返回值时，默认返回undefined</li>
</ol>
<h2 id="new操作符具体干了什么"><a href="#new操作符具体干了什么" class="headerlink" title="new操作符具体干了什么"></a>new操作符具体干了什么</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建了一个空对象</span><br><span class="line"><span class="keyword">var</span> obj =&#123;&#125;</span><br><span class="line"><span class="number">2.</span> 空对象的__proto__指向函数的prototype</span><br><span class="line">obj.__proto__ = 函数.prototype</span><br><span class="line"><span class="number">3.</span> 将对象作为函数的<span class="keyword">this</span>传进去，如果函数有<span class="keyword">return</span>，并且<span class="keyword">return</span>出来的东西是对象就直接返回这个对象，否则就返回创建的这个对象</span><br><span class="line">函数.apply(obj,参数)</span><br><span class="line"><span class="number">4.</span>将初始化完毕的新对象地址，赋值给等号左边的变量</span><br></pre></td></tr></table></figure>
<h3 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="comment">/* return [1,2,3] */</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Creat</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(fun.prototype)</span><br><span class="line">    <span class="keyword">const</span> fun_result = fun.apply(obj,args)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> fun_result == <span class="string">'object'</span> || <span class="keyword">typeof</span> fun_result == <span class="string">'function'</span> ? fun_result : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tom = Creat(Person,<span class="string">'Tom'</span>,<span class="number">12</span>)</span><br><span class="line"><span class="comment">/* let tom = new Person('tom',12) */</span></span><br><span class="line"><span class="built_in">console</span>.log(tom);</span><br><span class="line">tom.getName()</span><br><span class="line"><span class="built_in">console</span>.log(tom <span class="keyword">instanceof</span> Person);</span><br></pre></td></tr></table></figure>
<h2 id="同步和异步的区别，怎么异步加载javascript"><a href="#同步和异步的区别，怎么异步加载javascript" class="headerlink" title="同步和异步的区别，怎么异步加载javascript"></a>同步和异步的区别，怎么异步加载javascript</h2><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><p>同步模式，又称阻塞模式。javascript在默认情况下是阻塞加载。当前面的js请求没有处理和执行完成时会阻止浏览器的后续处理。</p>
<h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><p>异步模式又称非阻止模式，浏览器在下载执行js同时，还会继续进行后续页面的处理</p>
<ol>
<li>动态添加script标签</li>
<li>defer</li>
<li>async(h5)</li>
</ol>
<p>defer属性和async属性都属于script上面的，两者都能实现js的异步加载。不同的是async在异步加载完成的时候就马上开始执行，defer会等到html加载完成后，在window.onload之前执行，他们仅适用于外部脚本（只有在使用 src 属性时）</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>在JS中，对this的研究一般都是this的指向问题，核心就是this永远指向最终调用它的那个对象，除非改变this指向或者箭头函数的特殊情况</p>
<h2 id="call，apply，bind"><a href="#call，apply，bind" class="headerlink" title="call，apply，bind"></a>call，apply，bind</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>都可以改变this的指向</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol>
<li>apply方法传入两个参数，一个是作为函数上下文的对象，一个是函数参数组成的数组</li>
<li>call方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表</li>
<li>bind同call</li>
</ol>
<p>apply和call方法都会使函数立即执行，因此他们也可以用来调用函数</p>
<p>bind方法不会立即执行，而是返回了一个改变了上下文this的函数，同时bind返回的函数可以作为构造函数来使用</p>
<h3 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"不是函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span>(args) &#123;</span><br><span class="line">        result= contenxt.fn(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result= context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"不是函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span>(array) &#123;</span><br><span class="line">        result= contenxt.fn(...array)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result= context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"不是函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> arg1 = [...arguments].slice(<span class="number">1</span>),_this = <span class="keyword">this</span></span><br><span class="line">    bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> arg2 = [...arguments]</span><br><span class="line">        <span class="keyword">return</span> _this.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> bindFn ? <span class="keyword">this</span>: context, arg1.contact(arg2))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prototype = <span class="built_in">Object</span>.create(_this.prototype)</span><br><span class="line">    bindFn.prototype = prototype</span><br><span class="line">    bindFn.prototype.constructor = bindFn</span><br><span class="line">    <span class="keyword">return</span> bindFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h2><p>内存泄漏是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束</p>
<h3 id="可能导致内存泄漏的操作"><a href="#可能导致内存泄漏的操作" class="headerlink" title="可能导致内存泄漏的操作"></a>可能导致内存泄漏的操作</h3><ol>
<li>意外的全局变量</li>
<li>闭包</li>
<li>循环引用</li>
<li>被遗忘的定时器或者回调函数</li>
</ol>
<p>内存泄漏多了之后会导致内存溢出，使页面无法加载显示</p>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>事件代理通俗来说就是将元素的事件委托给父级或更外级的元素来处理</p>
<p>原理：利用事件的冒泡机制来处理</p>
<p>优点：只需要将同类元素的事件委托给父级或更外级的元素，不需要给所有元素都绑定事件，减少内存空间占用，提升性能，动态新增的元素也无需重新绑定事件</p>
<h2 id="CommonJS和ES6模块化"><a href="#CommonJS和ES6模块化" class="headerlink" title="CommonJS和ES6模块化"></a>CommonJS和ES6模块化</h2><h3 id="本质上区别"><a href="#本质上区别" class="headerlink" title="本质上区别"></a>本质上区别</h3><ol>
<li>无论CommonJS还是ES6模块输出都可以看成是一个具备多个属性或者方法的对象</li>
<li>default是ES6模块所独有的关键字，export default fs输出默认的接口对象，import fs from ‘fs’可直接导入这个对象</li>
<li>ES6模块中导入模块的属性或者方法是强绑定的包括基础类型，而CommonJS则是普通的值传递或者引用传递</li>
<li>ES6模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系以及输入输出的变量(静态优化)，CommonJS都只能在运行时确定这些东西(运行时加载)</li>
<li>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式，CommonJS模块是一个对象</li>
<li>CommonJS模块重要的特征是加载时执行，即脚本代码在require的时候就会全部执行。一旦出现某个模块被循环加载，就只输出已经执行的部分，还未执行的部分不会输出</li>
<li>ES6模块是动态引用，如果使用import从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者保证真正取值的时候能取得这些值</li>
</ol>
<h3 id="export和default-export的区别"><a href="#export和default-export的区别" class="headerlink" title="export和default export的区别"></a>export和default export的区别</h3><ol>
<li>两者均可用于导出常量，函数，文件，模块等</li>
<li>在一个文件或模块中，export、import可以有多个，而export default仅有一个</li>
<li>通过export方式导出，在导入的时候要加{}，export default不需要</li>
<li>使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名，export需要知道</li>
<li>export default命令的本质就是将后面的值，赋给default变量，所以可以直接将一个值写在最后</li>
</ol>
<h2 id="节流和去抖"><a href="#节流和去抖" class="headerlink" title="节流和去抖"></a>节流和去抖</h2><p>节流和去抖的区别：节流和去抖都是中间过程的函数被限制触发，但是节流是减少触发频率，去抖是把中间过程函数都过滤掉，只执行规定时间最后一个事件</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流是使得一定时间内只触发一次函数。原理是判断是否达到一定时间来触发函数，若还没到规定时间则用计时器延后，而下一次事件会重新设计定时器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> time = <span class="literal">null</span>,startTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">let</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">            <span class="keyword">const</span> remaining = currentTime-startTime-wait</span><br><span class="line">            <span class="keyword">if</span>(time) clearTimeout(time)</span><br><span class="line">            <span class="keyword">if</span>(remaining&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">                startTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                time = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">                &#125;,remaining)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如监听滚轮事件，一直快速滚动会再第一次执行方法后会建立定时器又销毁定时器的过程，直到间隔时间大于延迟时间，才触发第二次，在停止滚动后，最后一个定时器没被销毁，会执行最后一次方法</span></span><br></pre></td></tr></table></figure></p>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>将几次操作合并成一次操作执行。原理是维护一个定时器，触发事件后经过delay秒执行方法，如果在delay之间再次触发事件，会重新设置定时器，这样一来只有最后一次操作会执行方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> time = <span class="literal">null</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">if</span>(!immediate) &#123;</span><br><span class="line">                <span class="keyword">if</span>(time) clearTimeout(time)</span><br><span class="line">                time = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!time) &#123;</span><br><span class="line">                    func.apply(<span class="keyword">this</span>, args)             </span><br><span class="line">                &#125;   </span><br><span class="line">                time = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    clearTimeout(time)</span><br><span class="line">                &#125;,wait) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这个防抖效果是，当你触发事件后，至少要等delay秒才会执行方法，如果在delay秒之间再次触发事件，原来定时器会被销毁，重新开始一个定时器</span></span><br></pre></td></tr></table></figure>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><p>w3c定义事件发生经历三个阶段，捕获阶段，目标阶段，冒泡阶段</p>
<ol>
<li>冒泡事件：子级元素先触发，父级元素后触发</li>
<li>捕获事件：父级元素先触发，子级元素后触发</li>
<li>阻止冒泡：在w3c下使用stopPropagation()，在IE下使用cancelBubble = false</li>
<li>阻止捕获：相当于阻止默认行为，w3c中使用preventDefault(),在IE下使用returnValue = false</li>
<li>如果给一个节点同时注册捕获和冒泡事件，那么触发的顺序是注册的顺序</li>
</ol>
<h2 id="各种height和width和left和top的区别"><a href="#各种height和width和left和top的区别" class="headerlink" title="各种height和width和left和top的区别"></a>各种height和width和left和top的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    border: 5px solid lightgreen;</span><br><span class="line">    margin:50px auto;</span><br><span class="line">    background-color: lightskyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一-clientWidth和clientHeigh-、-clientTop和clientLeft"><a href="#一-clientWidth和clientHeigh-、-clientTop和clientLeft" class="headerlink" title="一.clientWidth和clientHeigh 、 clientTop和clientLeft"></a>一.clientWidth和clientHeigh 、 clientTop和clientLeft</h3><ol>
<li>clientWidth = width + 左右padding $(‘.box’)[0].clientWidth 240px</li>
<li>clientHeight = height + 上下padding $(‘.box’)[0].clientHeight 240px</li>
<li>clientTop = border-top $(‘.box’)[0].clientTop 5px</li>
<li>clientLeft = border-left $(‘.box’)[0].clientLeft 5px</li>
</ol>
<h3 id="二、offsetWidth和offsetHight-、-offsetTop和offsetLeft"><a href="#二、offsetWidth和offsetHight-、-offsetTop和offsetLeft" class="headerlink" title="二、offsetWidth和offsetHight 、 offsetTop和offsetLeft"></a>二、offsetWidth和offsetHight 、 offsetTop和offsetLeft</h3><ol>
<li>offsetWidth = width + 左右padding +左右border $(‘.box’)[0].offsetWidth 250px</li>
<li>offsetHeight = height + 上下padding + 上下border $(‘.box’)[0].offsetHeight 250px</li>
<li>offsetTop = 当前元素 上边框 外边缘 到 最近的已定位父级（offsetParent） 上边框 内边缘的 距离。如果父级都没有定位，则分别是到body 顶部 距离 $(‘.box’)[0].clientTop 50px</li>
<li>offsetLeft = 当前元素 左边框 外边缘 到 最近的已定位父级（offsetParent） 左边框 内边缘的            距离。如果父级都没有定位，则分别是到body 顶部 和左边的距离 $(‘.box’)[0].clientLeft 254px</li>
</ol>
<h3 id="三、scrollWidth和scrollHeight-scrollTop和scrollLeft"><a href="#三、scrollWidth和scrollHeight-scrollTop和scrollLeft" class="headerlink" title="三、scrollWidth和scrollHeight,scrollTop和scrollLeft"></a>三、scrollWidth和scrollHeight,scrollTop和scrollLeft</h3><ol>
<li>scrollWidth = 获取指定标签内容层的真实宽度（可视区域宽度+被隐藏区域宽度）</li>
<li>scrollHeight =   scrollHeight：获取指定标签内容层的真实高度（可视区域高度+被隐藏区域高度）</li>
<li>scrollTop = 内容层顶部 到 可视区域顶部的距离。</li>
<li>scrollLeft = 内容层左端 到 可视区域左端的距离.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="built_in">window</span>).scrollTop());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="JS的几种类型的值"><a href="#JS的几种类型的值" class="headerlink" title="JS的几种类型的值"></a>JS的几种类型的值</h2><ul>
<li>栈：存放原始数据类型(Null,Undefined,Number,String,Boolean,Symbol)</li>
<li>堆：存放引用数据类型(Array,Object,Function)</li>
<li>原始数据类型直接存储在栈中，占据空间小，大小固定</li>
<li>引用数据类型在栈中存储了指针，在堆中存储了对象，指针是一个地址，指向堆中实体的起始地址。当解释器寻找引用类型的值时，会首先检索其在栈中的地址，取得地址后从堆中取得实体</li>
</ul>
<p><img src="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" alt></p>
<h2 id="js中变量提升和函数提升的顺序"><a href="#js中变量提升和函数提升的顺序" class="headerlink" title="js中变量提升和函数提升的顺序"></a>js中变量提升和函数提升的顺序</h2><p>首先进行函数提升，随后进行变量声明的提升<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fun)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = <span class="number">000</span></span><br></pre></td></tr></table></figure></p>
<p>在上面这个情况，函数会优先提升，随后变量声明提升，但不会覆盖函数，等去到变量赋值阶段才会覆盖</p>
<h2 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">left,right</span>) </span>&#123;</span><br><span class="line">   left = left.__proto__;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == right.prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<h3 id="的转换顺序"><a href="#的转换顺序" class="headerlink" title="==的转换顺序"></a>==的转换顺序</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/19/167c4a2627fe55f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<ul>
<li>首先判断类型是否相同，相同的话直接比较大小</li>
<li>类型不同会先进行类型转换，先判断是不是null和undefined，是就返回true</li>
<li>判断两者是否为string和number，是就将字符串转换为number</li>
<li>判断一方是否为boolean，是就转换为number在进行判断</li>
<li>判断其中一方是否为object且另一方为string，number，或者symbol，是的话就会把object转为原始类型在进行判断(先使用valueof，没有就用toString)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[] == ![]  <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ![] =&gt; false</span></span><br><span class="line"><span class="comment">// false =&gt; 0</span></span><br><span class="line"><span class="comment">// [] =&gt; "" [].valueOf().toString() =&gt; ''</span></span><br><span class="line"><span class="comment">// "" =&gt; 0</span></span><br><span class="line"><span class="comment">//因此0 == 0 返回true</span></span><br><span class="line"></span><br><span class="line">&#123;&#125; == !&#123;&#125; <span class="literal">false</span></span><br><span class="line"><span class="comment">// !&#123;&#125; =&gt; false</span></span><br><span class="line"><span class="comment">// false =&gt; 0</span></span><br><span class="line"><span class="comment">// &#123;&#125; =&gt; '[object Object]' &#123;&#125;.valueOf().toString() =&gt; '[object Object]'</span></span><br><span class="line"><span class="comment">//因此 '[object Object]' == 0 返回false</span></span><br><span class="line"></span><br><span class="line">复杂数据类型会先转换成<span class="built_in">String</span>再转换成<span class="built_in">Number</span>运算</span><br><span class="line">[] == [] <span class="literal">false</span></span><br><span class="line">&#123;&#125; == &#123;&#125; <span class="literal">false</span></span><br><span class="line">[] == <span class="number">0</span> <span class="literal">true</span></span><br><span class="line">![] == <span class="number">0</span> <span class="literal">true</span></span><br><span class="line">&#123;&#125; == <span class="number">0</span> <span class="literal">false</span></span><br><span class="line">!&#123;&#125; == <span class="number">0</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    i:<span class="number">0</span></span><br><span class="line">    valueOf:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++a.i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a==<span class="number">2</span> &amp;&amp; a==<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JS垃圾回收"><a href="#JS垃圾回收" class="headerlink" title="JS垃圾回收"></a>JS垃圾回收</h2><h3 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p>一般俩说没有被引用的对象就是垃圾，如果几个对象引用形成一个环互相引用，但根访问不到他们，这几个对象也是垃圾。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JS的垃圾回收机制是为了防止内存泄漏，内存泄漏是指当已经不需要某块内存时这内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放他们所指向的内存</p>
<h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p>当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将他引用的内存释放(垃圾回收)，但全局变量的生命周期会持续到浏览器关闭。</p>
<h3 id="JS垃圾回收方式"><a href="#JS垃圾回收方式" class="headerlink" title="JS垃圾回收方式"></a>JS垃圾回收方式</h3><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>大部分浏览器用这种方式进行垃圾回收，当变量进入执行环境的时候，垃圾回收期将其标记为进入环境，离开环境的时候标记离开环境。他会标记所有可访问对象。第二阶段扫描收集所有未标记的对象(未被引用对象)，他们不会被立即回收，而是将一直累积到内存耗尽为止。当内存耗尽的时候程序被挂起，垃圾回收开始执行，当所有未引用对象被清理完毕程序才会继续执行</p>
<p>优化：垃圾回收分解成多部分，各部分分别进行，需要额外的标记跟踪变化，这样有很多微小的延迟而不是很大的延迟。存在足够久的对象会变“老”，接受检查次数变少。垃圾回收器只在CPU空闲运行，减少对执行的影响。</p>
<h4 id="引用计数-了解"><a href="#引用计数-了解" class="headerlink" title="引用计数(了解)"></a>引用计数(了解)</h4><p>常常会引起内存泄漏，低版本的IE会使用。跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数就是1。如果同一个值又被赋给另一个变量则该值的引用次数加1。如果包含对该值引用的变量又取得另一个值，则该值的引用次数减1。当该值得引用次数变为0时，则可以回收其占用的内存空间。垃圾回收器下一次运行时会释放那些引用次数为0的值所占用的内存。</p>
<p>缺点：循环引用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();  </span><br><span class="line">    <span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();  </span><br><span class="line">    objA.propertyA = objB;  </span><br><span class="line">    objB.propertyA = objA;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时objA和objB这两个值引用次数为2，函数结束销毁objA和objB变量，可是值引用次数只是减1，所以两个对象仍然继续存在无法被回收。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试题/" rel="tag"># 面试题</a>
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/22/彻底弄懂js事件执行机制/" rel="next" title="彻底弄懂js事件执行机制">
                <i class="fa fa-chevron-left"></i> 彻底弄懂js事件执行机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/06/vue知识点/" rel="prev" title="vue知识点">
                vue知识点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Gzzzh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型和原型链"><span class="nav-number">2.</span> <span class="nav-text">原型和原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">3.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分析"><span class="nav-number">3.1.</span> <span class="nav-text">分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">4.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#组合继承-最常用"><span class="nav-number">4.1.</span> <span class="nav-text">组合继承(最常用)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点："><span class="nav-number">4.1.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点："><span class="nav-number">4.1.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄生组合继承-最佳"><span class="nav-number">4.2.</span> <span class="nav-text">寄生组合继承(最佳)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点：-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">4.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class继承"><span class="nav-number">4.3.</span> <span class="nav-text">class继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点：-2"><span class="nav-number">4.3.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点：-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浅拷贝和深拷贝"><span class="nav-number">5.</span> <span class="nav-text">浅拷贝和深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言-1"><span class="nav-number">5.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝"><span class="nav-number">5.2.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝"><span class="nav-number">5.3.</span> <span class="nav-text">深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">5.3.1.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断JS数据类型"><span class="nav-number">6.</span> <span class="nav-text">判断JS数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof"><span class="nav-number">6.1.</span> <span class="nav-text">typeof</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么null返回的是object"><span class="nav-number">6.1.1.</span> <span class="nav-text">为什么null返回的是object</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof"><span class="nav-number">6.2.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor-NaN"><span class="nav-number">6.3.</span> <span class="nav-text">constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-NaN"><span class="nav-number">6.4.</span> <span class="nav-text">toString</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined和null的区别"><span class="nav-number">7.</span> <span class="nav-text">undefined和null的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">7.1.</span> <span class="nav-text">null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">7.2.</span> <span class="nav-text">undefined</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new操作符具体干了什么"><span class="nav-number">8.</span> <span class="nav-text">new操作符具体干了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自己实现"><span class="nav-number">8.1.</span> <span class="nav-text">自己实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步和异步的区别，怎么异步加载javascript"><span class="nav-number">9.</span> <span class="nav-text">同步和异步的区别，怎么异步加载javascript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步模式"><span class="nav-number">9.1.</span> <span class="nav-text">同步模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步模式"><span class="nav-number">9.2.</span> <span class="nav-text">异步模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-number">10.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call，apply，bind"><span class="nav-number">11.</span> <span class="nav-text">call，apply，bind</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相同点"><span class="nav-number">11.1.</span> <span class="nav-text">相同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同点"><span class="nav-number">11.2.</span> <span class="nav-text">不同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手写call"><span class="nav-number">11.3.</span> <span class="nav-text">手写call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手写apply"><span class="nav-number">11.4.</span> <span class="nav-text">手写apply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手写bind"><span class="nav-number">11.5.</span> <span class="nav-text">手写bind</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏和内存溢出"><span class="nav-number">12.</span> <span class="nav-text">内存泄漏和内存溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可能导致内存泄漏的操作"><span class="nav-number">12.1.</span> <span class="nav-text">可能导致内存泄漏的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件代理"><span class="nav-number">13.</span> <span class="nav-text">事件代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CommonJS和ES6模块化"><span class="nav-number">14.</span> <span class="nav-text">CommonJS和ES6模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本质上区别"><span class="nav-number">14.1.</span> <span class="nav-text">本质上区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#export和default-export的区别"><span class="nav-number">14.2.</span> <span class="nav-text">export和default export的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节流和去抖"><span class="nav-number">15.</span> <span class="nav-text">节流和去抖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#节流"><span class="nav-number">15.1.</span> <span class="nav-text">节流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防抖"><span class="nav-number">15.2.</span> <span class="nav-text">防抖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件模型"><span class="nav-number">16.</span> <span class="nav-text">事件模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各种height和width和left和top的区别"><span class="nav-number">17.</span> <span class="nav-text">各种height和width和left和top的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-clientWidth和clientHeigh-、-clientTop和clientLeft"><span class="nav-number">17.1.</span> <span class="nav-text">一.clientWidth和clientHeigh 、 clientTop和clientLeft</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、offsetWidth和offsetHight-、-offsetTop和offsetLeft"><span class="nav-number">17.2.</span> <span class="nav-text">二、offsetWidth和offsetHight 、 offsetTop和offsetLeft</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、scrollWidth和scrollHeight-scrollTop和scrollLeft"><span class="nav-number">17.3.</span> <span class="nav-text">三、scrollWidth和scrollHeight,scrollTop和scrollLeft</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS的几种类型的值"><span class="nav-number">18.</span> <span class="nav-text">JS的几种类型的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js中变量提升和函数提升的顺序"><span class="nav-number">19.</span> <span class="nav-text">js中变量提升和函数提升的顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手写instanceof"><span class="nav-number">20.</span> <span class="nav-text">手写instanceof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">21.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#的转换顺序"><span class="nav-number">21.1.</span> <span class="nav-text">==的转换顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS垃圾回收"><span class="nav-number">22.</span> <span class="nav-text">JS垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是垃圾？"><span class="nav-number">22.1.</span> <span class="nav-text">什么是垃圾？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">22.2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的生命周期"><span class="nav-number">22.3.</span> <span class="nav-text">变量的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS垃圾回收方式"><span class="nav-number">22.4.</span> <span class="nav-text">JS垃圾回收方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标记清除"><span class="nav-number">22.4.1.</span> <span class="nav-text">标记清除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数-了解"><span class="nav-number">22.4.2.</span> <span class="nav-text">引用计数(了解)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gzzzh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
